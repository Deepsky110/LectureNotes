<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title> Title </title>
<script type="text/javascript">

//    <타입>
//    boolean타입(true==1, true!--1, false==0 flase!==0)
    var a1;
    //    a1= true;
    a1=new Boolean(true);
    console.log(a1==true, a1===true, typeof a1);
    //  결과값 true false "object"
    //  a1===true : false 타입 비교 결과 같은 타입 아닌가? 왜 false일까?
    //  직접 객체를 생성한 결과인 a1은 Object로 나오기 때문에!

//    숫자타입(number, 실수형)
    var b1;
    b1=1234;
    b1=3.14;
    b1=3.0;
    b1=new Number(3.14);
    console.log(b1+1, typeof b1);
    //  결과값 4.140000000000001(실수형이라 오차값 존재) "object"
    console.log(b1.toString(), typeof b1.toString());
    //  결과값 3.14 string
    console.log(Number.isNaN(parseInt("$100"))); // 숫자로 시작해야 숫자로 인식
    //  isNaN 숫자가 아닌지 검사 is not a number?
    b1=1234;
    console.log(b1.toString(), typeof b1); // 자바에서는 배열에 사용
    //  parseInt하면 소수자리 제거됨
    //  parseFloat 소수점까지 가능
    
//    문자열타입
    c1='문자열'; // string
    //  slice : substring과 유사(추가로 인덱스로 -값 가능) // 뒤에서 부터 인덱스 계산
    //  substring은 자바와 같음
    //  substr -> (시작인덱스, 로부터 몇개까지)
    //  c1=new String(); // object
    console.log(c1.slice(0,2), typeof c1); // 문자열 뽑아내기
    
//    Array타입
    var d1;
    d1=new Array(); //[] "object"
    d1=[1,3,5,7,9]; // java식 표현 : {1,3,5,7,9};
    d1=new Array(2,4,6,8); // java: new int[]{2,4,6,8};
    d1=new Array(4); //숫자 하나 들어가면 length로 처리
    d1[0]='a';
    d1[1]='b';
    d1[2]='c'; // 자리는 있는데 입력하지 않으면 undefined
    d1[3]='d';
    d1[4]='e';
    console.log('length:'+d1.length, typeof d1);
    /* for(var i=0; i<d1.length; i++){
        console.log(d1[i]);
    }

    d1.forEach(func01);
    function func01(item, idx){
        console.log(item, idx);
    } */
    d1=[5,3,9,1];
    //  d1.sort(); // 정렬하기
    //  d1.reverse(); // 역으로 정렬
    
    d1.push(11); // 값이 동적으로 추가됨
    d1.push(12);
    /*
    console.log(d1.pop()); // 마지막 값부터 하나씩 꺼냄
    console.log(d1.pop()); // 자료구조로는 stack 구조에 해당
    console.log(d1.pop()); // reverse를 넣으면 que 구조로 바뀜
    console.log(d1.pop());
    console.log(d1.pop());
    console.log(d1.pop());

    console.log(d1.shift()); // 선입선출
    console.log(d1.shift()); // que 구조
    console.log(d1.shift());
    console.log(d1.shift());
    console.log(d1.shift());
    console.log(d1.shift()); // pop이나 shift를 통해 값을 추출하면 배열이 줄어듬

    while(true){
        if(d1.length==0)break;
        console.log(d1.pop()); // 반복문을 통해
    }
    
    var tmp;
    while(tmp=d1.pop()){
        console.log(tmp);
    } // undefined는 false
    
    d1.forEach(function(item,idx){
        console.log(item,idx);
    }) // 익명클래스랑 유사
    
    for(var idx in d1){
        console.log(idx, d1[idx]);
    } // 개선된 for문
    */
    d1.push(function(){console.log('array func');});
    d1[6]();
    
//    Object타입(자바의 Map타입)
    var e1;
    e1=new Object(); // 결과 : {} "ojbect"
    e1={'key1':'val1', 'key2':'val2'}; // {key1: "val1", key2: "val2"} "object"
    
    e1['key3'] = 1234; //값 추가하기
    e1['key4'] = true;
    e1[true] = 'val5';
    e1[d1] = 'val6'; // 위에서 설정한 d1을 키로 설정
    // e1[7] = 'val7'; // 배열인지 object인지 혼동 가능성이 있어 사용하지 않음
    window.e1['key8'] = [1,3,5,7];
    // 변수 선언을 안해도 window 오브젝트에 넣어주는 것(딕셔너리 타입{}) 
    e1.key10=function(){console.log('ket10의 value');};
    
    e1.key10(); //호출, 실행하기
    
    /*
    console.log('key8 '+e1['key8'][2], e1.key8[2]); // 5 5
    console.log(e1.key3); // 1234
    console.log(e1['key9'], e1.key9); // undefined undefined 없는 변수를 호출
    console.log(e1, typeof e1);
    // {key1: "val1", key2: "val2", key3: 1234, key4: true, true: "val5", …} "object"
    
    for(var key in e1){ // 딕셔너리 타입의 반복을 위해 for-in문 사용
    console.log(key, e1[key]);
    }
    */
    
//    function타입 ==> ex03.html 참고
    function func01(){
        console.log('func01');
    }
    
//    null타입
//    undefined타입

</script>
</head>

	<body>

</body>
</html>
